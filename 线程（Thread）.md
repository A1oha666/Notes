# 线程（Thread）

多线程是指在一个程序中同时执行多个线程，每个线程都有自己独立的执行路径。在多线程中，程序的执行可以同时进行多个任务，从而提高系统的资源利用率和响应性能。

在传统的单线程编程模型中，程序按照顺序执行，一次只处理一个任务。这种方式在某些情况下可能会导致效率低下或者无法满足需求。而多线程通过将任务拆分为多个子任务，并且在不同的线程上同时执行，从而实现并发处理。

# 进程与线程的关系

1. 定义：

    * 进程（Process）：是指一个程序在计算机上的执行实例。每个进程都拥有独立的内存空间、文件描述符、状态信息等。
    * 线程（Thread）：是进程中的一个执行路径，也被称为轻量级进程。一个进程可以包含多个线程，线程共享所属进程的资源，如内存空间、文件句柄等。
2. 关系：

    进程是操作系统进行资源分配和调度的基本单位，而线程是进程中独立执行的最小单位。一个进程可以拥有多个线程，这些线程共享同一进程的资源。

    在同一个进程中的多个线程之间可以通过共享内存来进行通信，相比于进程间通信（IPC），线程间通信更加高效和方便。

    线程之间的切换开销比进程之间的切换开销要小，因为线程共享进程的地址空间，切换时只需保存和恢复少量的寄存器状态即可。

    进程间是相互独立的，一个进程的崩溃不会影响其他进程；而线程之间是共享进程资源的，一个线程的错误可能会导致整个进程崩溃。
3. 优势：

    进程间的切换开销较大，但在多核处理器上可以实现真正的并行处理。多个进程可以同时执行不同的任务，提高了系统的资源利用率。

    线程间的切换开销较小，而且可以实现更细粒度的并发控制。线程可以同时执行多个子任务，实现并发操作，提高了系统的响应性能。
4. 应用：

    进程适用于需要隔离资源、保护数据完整性的场景。例如，操作系统中的各个进程相互隔离，互不干扰。

    线程适用于需要实现并发操作、提高计算机资源利用率的场景。例如，图形界面应用程序的界面响应和后台任务可以放在不同的线程中处理。

# 使用Thread类创建线程

1. 创建子类： 首先，需要创建一个继承自Thread类的子类。可以通过定义一个类并让它继承Thread类来实现：

    ```java
    public class MyThread extends Thread {
        // 线程执行的代码
        @Override
        public void run() {
            // 线程要执行的任务
        }
    }
    ```
2. 重写`run()`​方法： 在子类中，需要重写`Thread`​类中的`run()`​方法。`run()`​方法是线程的入口点，会在线程启动时被调用，其中包含了线程要执行的任务逻辑。
3. 创建线程对象： 在主线程或其他线程中，创建子类的对象作为线程对象：

    ```java
    MyThread myThread = new MyThread();
    ```
4. 启动线程： <u>调用线程对象的</u>​**​`start()`​** ​<u>方法来启动线程</u>，使其开始执行`run()`​方法中定义的任务逻辑：

    ```java
    myThread.start();
    ```

    **注意：** 不能直接调用`run()`​方法来启动线程，因为直接调用`run()`​方法<u>只会在当前线程中顺序执行，并不会创建新的线程。</u>
5. 线程执行结束： 当线程的`run()`​方法执行完毕或者线程被中断时，线程将自动结束。也可以在`run()`​方法中使用`return`​语句显式返回，来提前结束线程的执行。

```java
class ThreadDemo2 extends Thread {
    ThreadDemo2() {
    }
    ThreadDemo2(String name) {
        super(name);
    }
    //重载run函数
    public void run() {
        for (int count = 0,row = 1 ;row<10;count++,row++) {
            for (int i = 0; i < count; i++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}
public class ThreadDemo {
    public static void main(String[] args) {
        ThreadDemo2 t1 = new ThreadDemo2();
        ThreadDemo2 t2 = new ThreadDemo2();
        ThreadDemo2 t3 = new ThreadDemo2();
        t1.start();
        t2.start();
        t3.start();
    }
}
```

**注意：** Java线程并不能按调用顺序执行，而是并行执行的单独代码。

需要注意的是，通过继承Thread类创建线程的方法存在一些<u>限制和不足</u>：

* 由于Java是<u>单继承</u>的语言，因此一个类只能继承一个父类，如果已经继承了其他类，则无法再使用继承Thread类的方式创建线程。
* 继承Thread类会导致子类与Thread类高度耦合，违反了面向对象的设计原则。
* Thread类本身提供了许多方法和属性（如start、run、stop等），如果继承Thread类，子类将无法重写这些方法或隐藏这些属性。

为了克服以上限制和不足，更常用的创建线程的方式是实现`Runnable`​接口，并将其作为参数传递给Thread类的构造方法。这种方式可以更好地利用Java的接口特性，提高代码的灵活性和可复用性。

# Runnable接口创建线程

1. 创建实现类： 首先，需要创建一个实现了Runnable接口的类。可以定义一个类，并让它实现Runnable接口：

    ```java
    public class MyRunnable implements Runnable {
        // 线程执行的代码
        @Override
        public void run() {
            // 线程要执行的任务
        }
    }
    ```
2. 实现run()方法： 在实现类中，需要实现Runnable接口中的run()方法。run()方法是线程的入口点，包含了线程要执行的任务逻辑。
3. 创建线程对象： 在主线程或其他线程中，创建实现类的对象作为Runnable对象：

    ```java
    MyRunnable myRunnable = new MyRunnable();
    ```
4. 创建线程实例： 将Runnable对象作为参数传递给Thread类的构造方法，创建Thread类的实例：

    ```java
    Thread myThread = new Thread(myRunnable);
    ```
5. 启动线程： 调用线程对象的start()方法来启动线程，使其开始执行run()方法中定义的任务逻辑：

    ```java
    myThread.start();
    ```

    注意：不能直接调用run()方法来启动线程，因为直接调用run()方法只会在当前线程中顺序执行，并不会创建新的线程。
6. 线程执行结束： 当线程的run()方法执行完毕或者线程被中断时，线程将自动结束。也可以在run()方法中使用return语句显式返回，来提前结束线程的执行。

使用Runnable接口创建线程相比继承Thread类有以下优势：

* Java语言支持多实现，一个类可以实现多个接口，因此可以更灵活地创建线程。
* 通过实现Runnable接口，可以将任务逻辑与线程的启动和管理逻辑分离，使代码更清晰、结构更合理。
* Runnable对象可以作为参数传递给其他线程或线程池，实现更高级的线程管理和复用。

# 线程的生命周期

* **新建状态**（New）： 当线程对象被创建但还没有调用start()方法时，线程处于新建状态。此时该线程的资源已被分配，但尚未启动。
* **就绪状态**（Runnable）： 当线程调用了start()方法后，线程进入就绪状态。此时线程已经准备好执行，但还没有分配到CPU时间片。在就绪状态中，线程将等待获取CPU的执行权。
* **运行状态**（Running）： 线程获得了CPU的执行权，进入运行状态。此时线程的run()方法会被调用，并且线程开始执行任务逻辑。在运行状态中，线程会一直执行，直到主动让出CPU资源或被其他高优先级线程抢占CPU。
* **阻塞状态**（Blocked）： 在某些情况下，线程可能会由于某种原因而暂停执行，此时线程进入阻塞状态。例如，线程在等待某个锁的释放、等待IO操作完成、等待其他线程的通知等情况下会进入阻塞状态。当满足某些特定条件后，线程可以从阻塞状态转变为就绪状态，等待获取CPU的执行权。
* **等待状态**（Waiting）： 当线程等待某个特定条件的时候，它可能会进入等待状态。例如，线程调用了wait()方法或join()方法后会进入等待状态。只有当满足一定条件时，等待的线程才能继续执行。
* **超时等待状态**（Timed Waiting）： 在特定的时间范围内等待某个条件满足，线程处于超时等待状态。例如，线程调用了sleep()方法或带有超时参数的方法，线程会暂时停止执行，并在指定的时间后自动进入就绪状态。
* **终止状态**（Terminated）： 当线程的run()方法执行完毕或异常终止时，线程进入终止状态。此时线程已经结束执行，并释放了占用的资源。

# 线程调度

线程优先级是指操作系统对不同线程调度执行的相对优先顺序的一种设置。通过设置线程的优先级，可以影响线程在竞争CPU资源时的调度顺序，从而实现对线程执行的控制。

在Java中，线程优先级使用一个整数表示，范围从1到10，其中1是最低优先级，10是最高优先级。默认情况下，所有线程的优先级都为5（NORM\_PRIORITY）。可以使用`Thread`​类的`setPriority()`​方法设置线程的优先级，使用`getPriority()`​方法获取线程的优先级。

线程的优先级设置<u>并不能保证绝对精确的执行顺序</u>，只是给操作系统一个提示，让其在调度时<u>更有可能</u>先执行优先级较高的线程。操作系统的调度策略和实现方式可能会有所差异，因此在不同操作系统上，线程优先级的行为和效果可能会有所不同。

*需要注意的是，线程优先级的设置可能会受到操作系统的限制，例如某些操作系统可能只支持较少的优先级级别，或者将所有线程都视为相同优先级。此外，通过设置线程优先级来实现程序的正确性通常并不是一个好的做法，应该尽量避免过于依赖线程优先级来进行程序设计。尽管线程优先级的效果可能会因操作系统和硬件平台而异，但在某些情况下，合理设置线程优先级仍然是有意义的。例如，当某个线程需要更多的CPU时间来执行关键任务时，可以将其优先级设置为较高，以提高其执行的机会。然而，应该谨慎使用线程优先级，并且尽量避免过度依赖线程优先级的正确性。在编写多线程程序时，应该尽可能设计出不依赖于线程优先级的算法和逻辑，以保证程序的可移植性和可靠性。* 

 更多：<u>[守护线程、线程组、线程池](https://juejin.cn/post/7252171043396567096#heading-15)</u>

# 线程同步

当线程以并发模式访问共享数据时，共享数据可能会发生冲突。Java引入线程同步的概念，以实现共享数据的一致性。线程同步机制让多个线程有序的访问共享资源，防止多个线程同时修改共享数据导致的数据不一致、竞态条件等问题。

比如多线程出售火车票，线程Thread1和Thread2都可以出售火车票，Thread1查询数据库发现火车票T可以出售，准备出售此票时Thread2在数据库中也发现T可以出售，所以Thread2也将此票T售出。

为了解决此类问题，Java提供了“锁”机制实现线程的同步。

## 临界区

临界区是指访问共享资源的代码块或方法，只允许一个线程在同一时间内执行临界区的代码。

## 锁（Lock）

用于保护临界区，防止多个线程同时访问共享资源。在进入临界区之前，线程需要获取锁，否则不能进入临界区，在退出临界区时释放锁。

Java中锁机制的实现方式是使用`synchronized`​关键字。

## `synchronized`​关键字

**同步void方法：** 在方法声明中使用 `synchronized `​关键字 。当一个线程调用同步方法时，它将锁定该方法所属对象（即该方法的调用者），其他线程将无法同时调用该方法，直到该方法执行完毕或抛出异常释放锁。

```java
public synchronized void synchronizedMethod() {
    // 同步方法的代码块
}
```

**同步代码块：** 使用`synchronized`​关键字来修饰一段代码块。只有获取了同步代码块所属对象的锁的线程才能进入该代码块执行，其他线程需要等待锁的释放才能执行该代码块。如果锁对象是 `this`​，则锁的范围是当前实例。

```java
public void someMethod() {
	Object lockObject = new Object();
    synchronized (lockObject)
	{
        // 同步代码块
    }
}
```

*需要注意的是，synchronized 关键字虽然简单易用，但它的粒度比较大，可能会导致线程的竞争和等待时间过长。在性能要求较高的情况下，可以考虑使用更细粒度的锁（如ReentrantLock）或其他并发工具来实现线程同步*

## ~~volatile关键字~~

**注意：volatile的使用需要掌握一些复杂的技巧，在On Java中作者建议“完全不要使用它”，在现在的Java中，实际上可以永远避开使用这个关键字**

使用 volatile 关键字可以确保该变量在多线程环境下的可见性和禁止指令重排序，从而解决了多线程并发访问时可能出现的线程间数据不一致的问题。

1. 可见性： 当一个变量被声明为 volatile 时，它的值在多个线程之间是可见的。也就是说，当一个线程修改了被 volatile 修饰的变量的值时，其他线程能够立即看到这个改变，而不是使用自己的缓存值。
2. 禁止指令重排序： 编译器和处理器为了提高执行效率，可能会对指令进行重排序。在使用 volatile 关键字修饰的变量上进行读写操作时，不会发生指令重排序，从而保证了线程间操作顺序的一致性。
3. 适用场景： a. 对变量的写入操作不依赖于当前值，或者只有单个线程修改变量的值。 b. 对变量的读取操作不依赖于其他变量的状态。

*需要注意的是，volatile 关键字无法保证*​*<u>原子性</u>*​ *，即不能代替锁来实现复杂的同步需求。如果需要保证原子性操作，例如 i++ 操作，仍然需要使用 synchronized 关键字或*​*<u>原子类（如 AtomicInteger）</u>*​*来实现。*

# 线程通信

线程间的通信是指多个线程之间交换信息或共享数据的过程。在多线程编程中，线程间的通信主要有两种方式：共享内存和消息传递。

1. **共享内存：**  使用共享内存的方式，线程之间通过访问相同的共享变量来进行通信。共享变量可以是全局变量、实例变量或静态变量等。线程通过对共享变量的读写操作来实现数据的交换和共享。

    需要注意的是，使用共享内存方式进行线程间通信时，需要考虑线程安全问题，例如使用 synchronized 关键字或锁来保证数据的一致性。
2. **消息传递：**  使用消息传递的方式，线程之间通过发送和接收消息来进行通信。每个线程都有自己的消息队列，线程可以将消息发送到其他线程的消息队列中，其他线程再从队列中取出消息进行处理。

    使用消息传递方式进行线程间通信时，可以避免共享变量导致的一些线程安全问题。但需要注意同步机制，例如在消息队列中使用 wait() 和 notify() 方法来实现等待和唤醒操作。

## 生产者/消费者`Producer-consumer problem`​

这个模型是由两类线程构成：

* 生产者线程：“生产”产品，并把产品放到一个队列里；
* 消费者线程：“消费”产品。

有了这个队列，生产者就只需要关注生产，而不用管消费者的消费行为，更不用等待消费者线程执行完；消费者也只管消费，不用管生产者是怎么生产的，更不用等着生产者生产。

所以该模型实现了生产者和消费者之间的**解藕**和**异步**。

生产者和消费者之间的关系如下：

* 生产者生产前，如果共享数据没有被消费，则生产者等待；生产者生产后，通知消费者消费。
* 消费者消费前，如果共享数据已经被消费完，则消费者等待；消费者消费后，通知生产者生产

使用 `Object`​ 类里自带的 `wait()`​ 和 `notify()`​ 或者 `notifyAll()`​ 的消息通知机制。

上述描述中的**等待**，其实就是用 `wait()`​ 来实现的；

而**通知**，就是 `notify()`​ 或者 `notifyAll()`​ 。

基于这种消息通知机制，我们能够**平衡生产者和消费者之间的速度差异**。

如果生产者的生产速度很慢，但是消费者消费的很快，就像是我们每月工资就发两次，但是每天都要花钱，也就是 1:15.

那么我们就需要调整生产者（发工资）为 15 个线程，消费者保持 1 个线程

**总结下该模型的三大优点：解藕，异步，平衡速度差异。**

# 死锁（Deadlock）

两个或多个线程互相持有对方所需的资源而无法继续执行的情况，从而导致程序无法正常结束。

例如：

```java
public class DeadlockExample {
    private static Object lock1 = new Object();
    private static Object lock2 = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread 1 acquired lock1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock2) {
                    System.out.println("Thread 1 acquired lock2");
                }
            }
        });

        Thread thread2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("Thread 2 acquired lock2");
                synchronized (lock1) {
                    System.out.println("Thread 2 acquired lock1");
                }
            }
        });

        thread1.start();
        thread2.start();
    }
}
```

thread1线程获取lock1后，尝试获取lock2，而此时thread2线程已经获取了lock2，尝试获取lock1，因此两个线程互相等待对方释放资源，导致死锁。

Java语言本身并没有提供防止死锁的具体方法，在实际开发中，通常通过合理的资源使用和锁设计，以及合理的多线程调度策略来减少死锁的风险。

## 一些解决方案

* 死锁检测：通过算法检测系统是否发生死锁，并采取相应措施解除死锁。
* 死锁恢复：通过终止一个或多个死锁线程，释放资源，从而恢复程序正常执行

* 获取锁的顺序：确保多个线程获取共享资源的锁的顺序一致，避免循环等待。
* 超时机制：获取锁时设置超时时间，如果在规定时间内无法获取到锁，则放弃当前操作并释放已经获取的锁。
* 资源分配策略：合理地对资源进行分配和释放，避免过多的资源占用。

更多：并发编程

‍
